<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        background-color:#000;
        background: url('https://cs460.org/assignments/04/bg.jpg');
        background-size: cover;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
    <script id="vertexshader" type="glsl">
    attribute vec3 a_position;

    uniform mat4  u_transform;
    uniform float u_pointsize;

    void main(void) {
        gl_Position = u_transform * vec4(a_position, 1.0);
        gl_PointSize = u_pointsize;
    }
</script>
  
  <script id="fragmentshader" type="glsl">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {

      gl_FragColor = u_color;

    }
  </script>
  
  <script>

    var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;

    let keys = {};
    window.addEventListener('keydown', e => {keys[e.key] = true;});
    window.addEventListener('keyup', e => {keys[e.key] = false;});

    window.onload = function() {

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
 
      c = document.getElementById( 'c' ); // setup canvas
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); // setup GL context
      gl.viewport(0, 0, c.width, c.height );


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      // compile vertex shader
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );

      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      // compile fragment shader
      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );

      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      // attach and link the shaders
      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );

      gl.linkProgram( shaderprogram );

      gl.useProgram( shaderprogram );


      // create multiple rectangles
      all_fish = [];
      all_fish.push(createFish(
        new Float32Array([0,0,0]),
        new Float32Array([1,0,0,1]),
        1, 1
      ));

      all_fish[0].push(new Float32Array([0,0]));
      for (let i = 0; i<100;i++){
            const random_color = new Float32Array([Math.random(),Math.random(),Math.random(),Math.random()]);
            const random_offset = new Float32Array([Math.random()-Math.random(), Math.random()-Math.random(), 0]);
            const random_scale = Math.random()*0.3;
            all_fish.push( createFish(random_offset, random_color, random_scale, 1) );
      }

      animate();

    };


    function createFish(offset, color, scale=1, direction=1) {


      //************************************************************//
      //
      // CREATE GEOMETRY
      //
        var vertices = new Float32Array([
            0.5, 0.0, 0.0, // 0: nose
            0.2, 0.25, 0.0, // 1: upper body
            -0.2, 0.15, 0.0, // 2: upper tail base
            -0.4, 0.3, 0.0, // 3: upper tail tip
            -0.4, -0.3, 0.0, // 4: lower tail tip
            -0.2, -0.15, 0.0, // 5: lower tail base
            0.2, -0.25, 0.0 // 6: lower body
        ]);

      // now use indices
        var indices = new Uint8Array([
            0, 1, 6, // main body
            1, 2, 6, // upper mid-body
            2, 5, 6, // rear body
            2, 3, 5, // tail top
            3, 4, 5 // tail fin
        ]);

      var eye_vertex = new Float32Array([0.2, 0.2, 0.0]);
      var v_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer); // bind
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

      var i_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); // bind
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind


      var eye_v_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, eye_v_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      return [v_buffer, i_buffer, eye_v_buffer, offset, color, scale, direction];

    };

    var step_x = .01;
    var step_y = .01;
    var direction = -1;

 function animate() {

  requestAnimationFrame(animate);

  gl.clearColor( 0., 0., 0., 0.)
  gl.clear( gl.COLOR_BUFFER_BIT );
  gl.enable(gl.BLEND);
  gl.blendEquation(gl.FUNC_ADD);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.disable(gl.DEPTH_TEST);

  const t = performance.now() * 0.001; 

  for (var r = 1; r < all_fish.length; r++) {

    const current_buffers = all_fish[r];
    const current_v_buffer = current_buffers[0];
    const current_i_buffer = current_buffers[1];
    const current_eye_v_buffer = current_buffers[2];
    const current_offset = current_buffers[3];
    let current_color = current_buffers[4];
    const current_scale = current_buffers[5];
    let current_direction = current_buffers[6];

    current_offset[0] += current_direction * 0.01;
    current_offset[1] += (Math.random() - 0.5) * 0.02;

    if (current_offset[0] > 1.0) { 
      current_offset[0] = 1.0; current_direction = -1; }
    if (current_offset[0] < -1.0){ 
      current_offset[0] = -1.0; current_direction =  1; }

    if (current_offset[1] >  1.0) current_offset[1] =  1.0;
    if (current_offset[1] < -1.0) current_offset[1] = -1.0;

    current_buffers[6] = current_direction;


    gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );
    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );

    var a_position = gl.getAttribLocation( shaderprogram, 'a_position' );
    gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );
    gl.enableVertexAttribArray ( a_position );

    const u_color = gl.getUniformLocation(shaderprogram, 'u_color');
    const pulse = 0.6 + 0.4 * Math.sin(t * 2.0 + r * 0.3);
    current_color = new Float32Array([
      current_color[0] * pulse,
      current_color[1] * pulse,
      current_color[2] * pulse,
      1.0
    ]);
    gl.uniform4fv(u_color, current_color);

    const u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
    const theta = (Math.random() * 10) * Math.PI / 180.0;
    const c = Math.cos(theta), s = Math.sin(theta);
    const sx = current_direction * current_scale;
    const sy = current_scale;
    const transform = new Float32Array([
      sx * c, -sy * s, 0, 0,
      sx * s,  sy * c, 0, 0,
      0,       0,      1, 0,
      current_offset[0], current_offset[1], 0, 1
    ]);
    gl.uniformMatrix4fv(u_transform, false, transform);


    gl.drawElements( gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

    var u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
    gl.uniform1fv(u_pointsize, new Float32Array([current_scale*20.]));
    gl.enableVertexAttribArray(a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, current_eye_v_buffer);
    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position);
    gl.drawArrays(gl.POINTS, 0, 1);
  }

  {
    var r = 0;

    const current_buffers = all_fish[r];
    const current_v_buffer = current_buffers[0];
    const current_i_buffer = current_buffers[1];
    const current_eye_v_buffer = current_buffers[2];
    const current_offset = current_buffers[3];
    let current_color = current_buffers[4];
    const current_scale = current_buffers[5];
    let current_direction = current_buffers[6];

    const vel = current_buffers[7];
    const speed = 0.02;
    const right = (keys['ArrowRight'] || keys['d']) ? 1 : 0;
    const left  = (keys['ArrowLeft']  || keys['a']) ? 1 : 0;
    const up    = (keys['ArrowUp']    || keys['w']) ? 1 : 0;
    const down  = (keys['ArrowDown']  || keys['s']) ? 1 : 0;

    vel[0] = (right - left) * speed;
    vel[1] = (up - down)    * speed;

    current_offset[0] += vel[0];
    current_offset[1] += vel[1];

    current_offset[0] = Math.max(-0.98, Math.min(0.98, current_offset[0]));
    current_offset[1] = Math.max(-0.98, Math.min(0.98, current_offset[1]));
    if (vel[0] !== 0) current_buffers[6] = current_direction = (vel[0] >= 0 ? 1 : -1);

    gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );
    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );

    var a_position = gl.getAttribLocation( shaderprogram, 'a_position' );
    gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );
    gl.enableVertexAttribArray ( a_position );

    const u_color = gl.getUniformLocation(shaderprogram, 'u_color');
    const pulse = 0.7 + 0.3 * Math.sin(t * 2.0);
    current_color = new Float32Array([1.0 * pulse, 0.0, 0.0, 0.9]);
    gl.uniform4fv(u_color, current_color);

    const u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
    const theta = (Math.random() * 10) * Math.PI / 180.0;
    const c = Math.cos(theta), s = Math.sin(theta);
    const sx = current_direction * current_scale;
    const sy = current_scale;
    const transform = new Float32Array([
      sx * c, -sy * s, 0, 0,
      sx * s,  sy * c, 0, 0,
      0,       0,      1, 0,
      current_offset[0], current_offset[1], 0, 1
    ]);
    gl.uniformMatrix4fv(u_transform, false, transform);

    gl.drawElements( gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

    var u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
    gl.uniform1fv(u_pointsize, new Float32Array([current_scale*20.]));
    gl.enableVertexAttribArray(a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, current_eye_v_buffer);
    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position);
    gl.uniform4fv(u_color, new Float32Array([0,0,0,1]));
    gl.drawArrays(gl.POINTS, 0, 1);
  }
}

  </script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>
